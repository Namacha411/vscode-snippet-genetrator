{
	"get_files.rs": {
		"scope": "rs",
		"prefix": "get_files.rs",
		"body": [
			"use std::fs::{self, DirEntry};",
			"use std::{io, path::Path};",
			"",
			"pub struct VisitDir {",
			"    root: Box<dyn Iterator<Item = io::Result<DirEntry>>>,",
			"    children: Box<dyn Iterator<Item = VisitDir>>,",
			"}",
			"",
			"impl VisitDir {",
			"    pub fn new<P: AsRef<Path>>(path: P) -> io::Result<Self> {",
			"        let root = Box::new(fs::read_dir(&path)?);",
			"        let children = Box::new(fs::read_dir(&path)?.filter_map(|e| {",
			"            let e = e.ok()?;",
			"            if e.file_type().ok()?.is_dir() {",
			"                return Some(VisitDir::new(e.path()).ok()?);",
			"            }",
			"            None",
			"        }));",
			"        Ok(VisitDir { root, children })",
			"    }",
			"",
			"    pub fn entries(self) -> Box<dyn Iterator<Item = io::Result<DirEntry>>> {",
			"        Box::new(",
			"            self.root",
			"                .chain(self.children.map(|s| s.entries()).flatten()),",
			"        )",
			"    }",
			"}",
			"",
			"impl Iterator for VisitDir {",
			"    type Item = io::Result<DirEntry>;",
			"    fn next(&mut self) -> Option<Self::Item> {",
			"        if let Some(item) = self.root.next() {",
			"            return Some(item);",
			"        }",
			"        if let Some(child) = self.children.next() {",
			"            self.root = child.entries();",
			"            return self.next();",
			"        }",
			"        None",
			"    }",
			"}"
		]
	},
	"main.rs": {
		"scope": "rs",
		"prefix": "main.rs",
		"body": [
			"mod get_files;",
			"mod make_json;",
			"",
			"use std::io;",
			"use get_files::VisitDir;",
			"use make_json::*;",
			"",
			"fn main() -> io::Result<()> {",
			"    let extention = \"rs\";",
			"    let paths = VisitDir::new(\".\")?.collect::<Vec<_>>();",
			"    let paths = paths",
			"        .into_iter()",
			"        .filter_map(|e| e.ok())",
			"        .map(|e| e.path())",
			"        .filter(|e| e.extension().is_some())",
			"        .filter(|e| e.extension().unwrap() == extention)",
			"        .collect::<Vec<_>>();",
			"",
			"    print!(\"{{\");",
			"    for path in paths {",
			"        let name = path.file_name().unwrap().to_str().unwrap().to_string();",
			"        print!(\"\\\"{}\\\":\", name);",
			"        let mut snippet = Snippet::new(extention.to_string(), path);",
			"        let snippet = snippet.make_json().unwrap();",
			"        print!(\"{},\", snippet);",
			"    }",
			"    print!(\"}}\");",
			"    Ok(())",
			"}"
		]
	},
	"make_json.rs": {
		"scope": "rs",
		"prefix": "make_json.rs",
		"body": [
			"use std::error::Error;",
			"use std::io::{self, BufRead};",
			"use std::path::Path;",
			"use std::result::Result;",
			"use std::{fs::File, path::PathBuf};",
			"",
			"use serde::Serialize;",
			"",
			"pub struct Snippet {",
			"    scope: String,",
			"    path: PathBuf,",
			"}",
			"",
			"impl Snippet {",
			"    pub fn new(scope: String, path: PathBuf) -> Snippet {",
			"        Snippet { scope, path }",
			"    }",
			"",
			"    pub fn make_json(&mut self) -> Result<String, Box<dyn Error>> {",
			"        #[derive(Debug, Serialize)]",
			"        pub struct Json {",
			"            scope: String,",
			"            prefix: String,",
			"            body: Vec<String>,",
			"        }",
			"        let scope = self.scope.clone();",
			"        let prefix = self.path.file_name().unwrap().to_str().unwrap().to_string();",
			"        let body = make_body(self.path.clone())?;",
			"        let json = Json {",
			"            scope,",
			"            prefix,",
			"            body,",
			"        };",
			"        let json = serde_json::to_string(&json)?;",
			"        Ok(json)",
			"    }",
			"}",
			"",
			"fn make_body(path: PathBuf) -> io::Result<Vec<String>> {",
			"    let lines = read_lines(path)?;",
			"    let s = lines.filter_map(|s| s.ok()).collect::<Vec<String>>();",
			"    Ok(s)",
			"}",
			"",
			"fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>",
			"where",
			"    P: AsRef<Path>,",
			"{",
			"    let file = File::open(filename)?;",
			"    Ok(io::BufReader::new(file).lines())",
			"}"
		]
	}
}